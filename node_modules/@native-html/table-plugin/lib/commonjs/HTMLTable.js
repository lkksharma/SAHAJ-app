"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HTMLTable = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactNative = require("react-native");

var _webshell = require("@formidable-webview/webshell");

var _pluginsCore = require("@native-html/plugins-core");

var _cssRules = require("./css-rules");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const styles = _reactNative.StyleSheet.create({
  container: {
    flex: 1,
    // See https://github.com/react-native-community/react-native-webview/issues/101
    overflow: 'hidden'
  }
});

const defaultInsets = {
  top: 0,
  bottom: 0,
  left: 0,
  right: 0
};
const DEFAULT_TRANSITION_DURATION = 120;

function animateNextFrames(duration) {
  _reactNative.LayoutAnimation.configureNext({
    duration: duration || DEFAULT_TRANSITION_DURATION,
    update: {
      type: _reactNative.LayoutAnimation.Types.easeInEaseOut
    }
  });
}

const tableStylePropTypeSpec = {
  linkColor: _propTypes.default.string,
  fontFamily: _propTypes.default.string,
  fontSizePx: _propTypes.default.number,
  tdBorderColor: _propTypes.default.string,
  thBorderColor: _propTypes.default.string,
  trOddBackground: _propTypes.default.string,
  trOddColor: _propTypes.default.string,
  trEvenBackground: _propTypes.default.string,
  trEvenColor: _propTypes.default.string,
  rowsBorderWidthPx: _propTypes.default.number,
  columnsBorderWidthPx: _propTypes.default.number,
  outerBorderColor: _propTypes.default.string,
  outerBorderWidthPx: _propTypes.default.number,
  cellPaddingEm: _propTypes.default.number,
  fitContainerWidth: _propTypes.default.bool,
  fitContainerHeight: _propTypes.default.bool,
  selectableText: _propTypes.default.bool,
  thEvenBackground: _propTypes.default.string,
  thEvenColor: _propTypes.default.string,
  thOddBackground: _propTypes.default.string,
  thOddColor: _propTypes.default.string
};

function findHeight({
  computeContainerHeight,
  computeHeuristicContentHeight,
  contentHeight,
  ...stats
}) {
  if (typeof contentHeight === 'number') {
    return computeContainerHeight({
      type: 'accurate',
      contentHeight: contentHeight
    });
  }

  return computeContainerHeight({
    type: 'heuristic',
    contentHeight: computeHeuristicContentHeight(stats)
  });
}

function defaultComputeHeuristicContentHeight(tableStats) {
  const {
    numOfChars,
    numOfRows
  } = tableStats;

  const width = _reactNative.Dimensions.get('window').width;

  const charsPerLine = 30 * width / 400;
  const lineHeight = 20;
  const approxNumOfLines = Math.floor(numOfChars / charsPerLine);
  return Math.max(approxNumOfLines, numOfRows) * lineHeight;
}

function defaultComputeContainerHeight(state) {
  return state.contentHeight;
}

function useAnimatedAutoheight({
  computeContainerHeight,
  computeHeuristicContentHeight,
  animationType,
  animationDuration,
  webViewProps,
  numOfChars,
  numOfColumns,
  numOfRows
}) {
  const animatedHeight = (0, _react.useRef)(new _reactNative.Animated.Value(0)).current;
  const {
    autoheightWebshellProps,
    contentSize,
    syncState
  } = (0, _webshell.useAutoheight)({
    webshellProps: webViewProps,
    resetHeightOnViewportWidthChange: false
  });
  const containerHeight = (0, _react.useMemo)(() => findHeight({
    computeContainerHeight,
    computeHeuristicContentHeight,
    contentHeight: syncState === 'synced' ? contentSize.height || 0 : null,
    numOfChars,
    numOfColumns,
    numOfRows
  }), [computeContainerHeight, computeHeuristicContentHeight, contentSize.height, syncState, numOfChars, numOfColumns, numOfRows]);
  const oldContainerHeightRef = (0, _react.useRef)(containerHeight);
  const containerStyle = (0, _react.useMemo)(() => animationType === 'animated' && containerHeight !== null ? {
    height: animatedHeight.interpolate({
      inputRange: [0, 1],
      outputRange: [oldContainerHeightRef.current || containerHeight, containerHeight]
    })
  } : {
    height: !containerHeight || Number.isNaN(containerHeight) ? undefined : containerHeight
  }, [animatedHeight, animationType, containerHeight]);
  (0, _react.useLayoutEffect)(() => {
    if (oldContainerHeightRef.current !== containerHeight) {
      oldContainerHeightRef.current = containerHeight;

      if (animationType === 'animated') {
        _reactNative.Animated.timing(animatedHeight, {
          toValue: 1,
          duration: animationDuration,
          useNativeDriver: false
        }).start();
      } else if (animationType === 'layout') {
        animateNextFrames(animationDuration);
      }
    }
  }, [containerHeight, animationDuration, animationType, animatedHeight]);
  return {
    containerStyle,
    autoheightWebshellProps
  };
}

function useSource({
  tableStyleSpecs,
  cssRules,
  sourceBaseUrl,
  html,
  maxScale
}) {
  const injectedHtml = (0, _react.useMemo)(() => {
    const styleSpecs = tableStyleSpecs ? { ..._cssRules.defaultTableStylesSpecs,
      ...tableStyleSpecs
    } : _cssRules.defaultTableStylesSpecs;
    const tableCssStyle = typeof cssRules === 'string' ? cssRules : (0, _cssRules.cssRulesFromSpecs)(styleSpecs);
    return "\n  <!DOCTYPE html>\n  <html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=".concat(Math.max(1, typeof maxScale !== 'number' || Number.isNaN(maxScale) ? 1 : maxScale), "\">\n    <title>Table</title>\n    <style>").concat(tableCssStyle, "</style>\n  </head>\n  <body>").concat(html, "</body>\n  </html>\n        ");
  }, [tableStyleSpecs, cssRules, html, maxScale]);
  return (0, _react.useMemo)(() => ({
    html: injectedHtml,
    baseUrl: sourceBaseUrl !== null && sourceBaseUrl !== void 0 ? sourceBaseUrl : undefined
  }), [injectedHtml, sourceBaseUrl]);
}

const features = [new _webshell.HandleLinkPressFeature(), new _webshell.HandleHTMLDimensionsFeature()];
/**
 * A component capable of rendering a html string which root tag is a table
 * tag. This component should not be used directly, except with custom
 * renderers.
 *
 * @public
 */

const HTMLTable = function HTMLTable({
  WebView,
  tableStyleSpecs,
  cssRules,
  html,
  sourceBaseUrl,
  animationType,
  computeHeuristicContentHeight = defaultComputeHeuristicContentHeight,
  computeContainerHeight = defaultComputeContainerHeight,
  webViewProps: userWebViewProps,
  style,
  onLinkPress,
  animationDuration,
  htmlAttribs,
  maxScale,
  ...stats
}) {
  const onDOMLinkPress = (0, _react.useCallback)(event => onLinkPress === null || onLinkPress === void 0 ? void 0 : onLinkPress.apply(null, (0, _pluginsCore.linkPressTargetToOnDOMLinkPressArgs)(event)), [onLinkPress]);
  const {
    autoheightWebshellProps,
    containerStyle
  } = useAnimatedAutoheight({ ...stats,
    animationDuration,
    animationType,
    computeContainerHeight,
    computeHeuristicContentHeight,
    webViewProps: {
      scalesPageToFit: _reactNative.Platform.select({
        android: false,
        ios: undefined
      }),
      automaticallyAdjustContentInsets: false,
      scrollEnabled: true,
      contentInset: defaultInsets,
      ...userWebViewProps,
      onDOMLinkPress,
      source: useSource({
        html,
        cssRules,
        sourceBaseUrl,
        tableStyleSpecs
      }),
      webshellDebug: false
    }
  });
  const webViewProps = (0, _webshell.useWebshell)({
    features,
    props: autoheightWebshellProps
  });
  return /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, {
    testID: "html-table-container",
    style: [containerStyle, styles.container, style]
  }, /*#__PURE__*/_react.default.createElement(WebView, webViewProps));
};

exports.HTMLTable = HTMLTable;
const propTypes = {
  animationDuration: _propTypes.default.number.isRequired,
  animationType: _propTypes.default.oneOf(['none', 'animated', 'layout']),
  computeContainerHeight: _propTypes.default.func.isRequired,
  computeHeuristicContentHeight: _propTypes.default.func.isRequired,
  html: _propTypes.default.string.isRequired,
  numOfChars: _propTypes.default.number.isRequired,
  numOfColumns: _propTypes.default.number.isRequired,
  numOfRows: _propTypes.default.number.isRequired,
  WebView: _propTypes.default.elementType.isRequired,
  onLinkPress: _propTypes.default.func,
  style: _propTypes.default.any,
  tableStyleSpecs: _propTypes.default.shape(tableStylePropTypeSpec),
  cssRules: _propTypes.default.string,
  webViewProps: _propTypes.default.object,
  sourceBaseUrl: _propTypes.default.string,
  maxScale: _propTypes.default.number.isRequired,
  htmlAttribs: _propTypes.default.any,
  displayMode: _propTypes.default.oneOf(['flex', 'expand'])
};
const defaultProps = {
  animationDuration: DEFAULT_TRANSITION_DURATION,
  animationType: 'animated',
  computeHeuristicContentHeight: defaultComputeHeuristicContentHeight,
  computeContainerHeight: defaultComputeContainerHeight,
  maxScale: 1
};
Object.defineProperty(HTMLTable, 'propTypes', {
  value: propTypes
});
Object.defineProperty(HTMLTable, 'defaultProps', {
  value: defaultProps
});
//# sourceMappingURL=HTMLTable.js.map