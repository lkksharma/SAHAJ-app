"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useHtmlIframeProps;

var _reactNative = require("react-native");

var _reactNativeRenderHtml = require("react-native-render-html");

var _extractPrintDimensions = _interopRequireDefault(require("./extractPrintDimensions"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultIframeConfig = {
  webViewProps: {
    allowsFullscreenVideo: true
  }
};
/**
 * Extract props for the HTMLIframe component from renderer function arguments.
 * This function is especially usefull for custom iframe renderers.
 *
 * @param props - The props of a custom block renderer.
 * @param iframeConfig - Override config options.
 *
 * @public
 */

function useHtmlIframeProps({
  style,
  tnode
}, iframeConfig) {
  const {
    WebView,
    defaultWebViewProps,
    computeEmbeddedMaxWidth,
    provideEmbeddedHeaders
  } = (0, _reactNativeRenderHtml.useSharedProps)();
  const contentWidth = (0, _reactNativeRenderHtml.useContentWidth)();
  const globalIframeConfig = (0, _reactNativeRenderHtml.useRendererProps)('iframe');
  const {
    onPress: onLinkPress
  } = (0, _reactNativeRenderHtml.useRendererProps)('a');
  const resolvedConfig = { ...defaultIframeConfig,
    ...globalIframeConfig,
    ...iframeConfig,
    webViewProps: { ...defaultWebViewProps,
      ...defaultIframeConfig.webViewProps,
      ...(globalIframeConfig === null || globalIframeConfig === void 0 ? void 0 : globalIframeConfig.webViewProps),
      ...(iframeConfig === null || iframeConfig === void 0 ? void 0 : iframeConfig.webViewProps)
    }
  };
  const resolvedContentWidth = typeof contentWidth === 'number' ? contentWidth : _reactNative.Dimensions.get('window').width;
  const documentBaseUrl = (0, _reactNativeRenderHtml.useDocumentMetadata)().baseUrl;
  const availableWidth = (computeEmbeddedMaxWidth === null || computeEmbeddedMaxWidth === void 0 ? void 0 : computeEmbeddedMaxWidth.call(null, resolvedContentWidth, 'iframe')) || resolvedContentWidth;
  const htmlAttribs = tnode.attributes;
  const normalizedUrl = (0, _reactNativeRenderHtml.useNormalizedUrl)(htmlAttribs.src);
  const {
    width,
    height,
    ...restStyle
  } = style;
  const attrWidth = Number(htmlAttribs.width);
  const attrHeight = Number(htmlAttribs.height);
  const printConfig = {
    attrWidth: Number.isNaN(attrWidth) ? null : attrWidth,
    attrHeight: Number.isNaN(attrHeight) ? null : attrHeight,
    styleWidth: typeof width === 'string' ? null : width,
    styleHeight: typeof height === 'string' ? null : height,
    contentWidth: availableWidth
  };
  const {
    printWidth,
    printHeight
  } = (0, _extractPrintDimensions.default)(printConfig);
  const scaleFactor = typeof printConfig.attrWidth === 'number' && printConfig.attrWidth > printWidth ? printWidth / attrWidth : 1;
  const source = htmlAttribs.srcdoc ? {
    html: htmlAttribs.srcdoc,
    baseUrl: documentBaseUrl
  } : {
    uri: normalizedUrl,
    headers: provideEmbeddedHeaders === null || provideEmbeddedHeaders === void 0 ? void 0 : provideEmbeddedHeaders(normalizedUrl, 'iframe', {
      printHeight,
      printWidth
    })
  };
  return { ...resolvedConfig,
    source,
    onLinkPress,
    htmlAttribs,
    scaleFactor,
    style: [restStyle, {
      width: printWidth,
      height: printHeight
    }],
    WebView
  };
}
//# sourceMappingURL=useHtmlIframeProps.js.map